### 时间复杂度

### 大O是什么？(在业界一般计算上界，即最坏的情况)

`n`表示数据规模

`O(f(n))`表示运行算法所需执行的指令数，和f(n)成正比

| 方法               | 所需指令数   |
| ---------------- | ------- |
| 二分查找法O(logn)     | a*logn  |
| 寻找数组中的最大/最小值O(n) | b*n     |
| 归并排序算法O(nlogn)   | c*nlogn |
| 选择排序法O(n^2)      | d*n^2   |

> a,b,c,d均为常数，因为其影响不大，在具体表示的时候不写出

#### 问题：有一个字符串数组，将数组中的每一个字符串都按字母序排序，之后再将整个字符串数组按照字典排序。计算整个时间复杂度

假设最长(考虑上界)的字符串长度为`s`，数组中有`n`个字符串

对每个字符串排序：`O(slongs)`

将数组中的每一个字符串按照字母序排序：`O(n*slog(s))`

将整个字符串数组按照字典序排序: `O(s*nlog(n))`;因为每一项都是字符串，所以要加上乘以s

最后整个过程：`O(n*slog(s))` + `O(s*nlog(n))` = `O(n*slog(s) + s*nlog(n))`

### 数据规模(n)

10^5的数据进行选择排序,计算机假死?

如果想要在1s之内解决问题:

O(n^2)的算法可以处理大约10^4级别的数据(10^3绝对可以)

O(n)的算法可以处理大约10^8级别的数据(10^7绝对可以)

o(nlogn)的算法可以处理大约10^7级别的数据(10^6绝对可以)

### 空间复杂度

额外的空间:

多开一个辅助的数组:O(n)

多开一个辅助的二维数组:O(n^2)

多开常数空间:O(1)

递归调用有空间代价的

### 常见的复杂度分析

#### O(1)

```c++
void swapTwoInts (int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}
```

#### O(n)

```c++
int sum (int n) {
  int ret = 0;
    for (int i = 0; i <= n; i++)
      ret += i
    return ret
}
```

一般包含一个循环,循环的次数和n相关

#### O(n^2)

选择排序,一般包含双重循环,和n相关

#### O(logn)

二分查找